<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Savi Virolainen" />

<meta name="date" content="2020-01-16" />

<title>Introduction to uGMAR</title>






<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to uGMAR</h1>
<h4 class="author">Savi Virolainen</h4>
<h4 class="date">2020-01-16</h4>



<p>The package <strong>uGMAR</strong> contains tools to estimate and analyze univariate Gaussian mixture autoregressive (GMAR), Student’s t mixture autoregressive (StMAR) and Gaussian and Student’s t mixture autoregressive (G-StMAR) models. We refer to these three models as the GSMAR models. This vignette does not explain details about the models and it’s assumed that the reader is familiar with the cited articles introducing the models. There are currently no published references for the G-StMAR model, so it will be discussed briefly in the section “The G-StMAR model”.</p>
<p>The models in <strong>uGMAR</strong> are defined as class <code>gsmar</code> S3 objects whose can be created with the estimation function <code>fitGSMAR</code> or with the constructor function <code>GSMAR</code>. The created <code>gsmar</code> objects can then be conveniently used as main arguments in several other functions, allowing one for example to perform quantile residual based model diagnostics, simulate from the processes, and to forecast. It’s thus easy to carry out further analyses after the model has been estimated. Some tasks, however, such as setting up initial population for the genetic algorithm, applying linear constraints or building <code>gsmar</code> models with pre-specified parameter values, require knowledge of the model details such as the form of the parameter vector. These details will be therefore explained in this vignette.</p>
<p>The rest of this vignette is organized as follows. In the first section it’s explained what the G-StMAR model is and when and why one should use it. In the second section notations for the parameter vector are described in detail, and it’s also shown how to apply constraints to autoregressive parameters of the models. Finally, in the third section some useful functions provided by <strong>uGMAR</strong> are briefly described.</p>
<div id="the-g-stmar-model" class="section level2">
<h2>The G-StMAR model</h2>
<p>To motivate introduction of the G-StMAR model, observe that the conditional variances of the component processes of the StMAR model depend on the past observations through the same parameters as the conditional means. This specific formulation is required to obtain the stationary Student’s t autoregressions, and it also enables the model to capture stronger forms conditional heteroskedasticity than the Gaussian case. However, this relation between the component specific conditional variance and mean might be restrictive if some regimes exhibit strong conditional mean but weak conditional variance (or vice versa). If such case occurs in a series modeled with the StMAR model, the degrees of freedom parameters of the corresponding regimes will get large estimates, for it makes the component process’s conditional variance of approach a constant variance parameter (which equals conditional variance of the linear Gaussian autoregressions that the GMAR model considers as its component processes). Moreover, since a large degrees of freedom parameter value makes the shape the innovations’ distribution to resemble Gaussian distribution, it seems natural to allow these regimes to be Gaussian, resulting the G-StMAR model.</p>
<p>The G-StMAR model can be described as a combination of the GMAR and the StMAR model. Its first <code>M1</code> component processes are taken to be linear Gaussian autoregressions as in the GMAR model, and the rest <code>M2</code> component processes are taken to be conditionally heteroscedastic linear Student’s t autoregressions as in the StMAR model, yielding total of <code>M1+M2=M</code> mixture components. Theoretical and practical properties of the G-StMAR model are similar to the ones of the GMAR model and the StMAR model. The conditional and also stationary distribution of a G-StMAR process is a mixture of Gaussian distributions and Student’s t distributions.</p>
<p>Besides reducing redundant parameters from the model, using the G-StMAR model instead of the StMAR model with large degrees of freedom parameters also comes with further advantages. One problem with very large degrees of freedom parameters is that their profile log-likelihoods are very flat near the estimates implying very low information indicating a near-indentification problem. Moreover, very large degrees of freedom parameter values cause inconsistent numerical inaccuracies in calculation of the log-likelihood function values and thus makes numerical approximations its derivatives biased. Approximate standard errors (obtained from numerically approximated observed information matrix) therefore become spurious and the first and second order conditions inaccessible for checking whether an estimate denotes a maximum point. The problems disappear when one reduces the problematic degrees of freedom parameters by switching to a G-StMAR model. Furthermore, <strong>uGMAR</strong>’s implementation of the quantile residual tests proposed by Kalliovirta (2012) is not applicable for models with such near-identification problem.</p>
</div>
<div id="parameter-vector-and-constraints" class="section level2">
<h2>Parameter vector and constraints</h2>
<p>Building a GSMAR model requires the user to specify the autoregressive (AR) order of the model <code>p</code> and the number of mixture components <code>M</code>. For the G-StMAR model one has to define the number of GMAR type components <code>M1</code> and the number of StMAR type components <code>M2</code>. If one wished to build a model with pre-specified parameter values rather than estimating them, knowledge of the exact form of the parameter vector is obviously necessary. In <strong>uGMAR</strong>, the form of the parameter vector depends on specifics of the model: is GMAR, StMAR or G-StMAR model considered, are all the AR coefficients restricted to be the same for all regimes and/or are linear constraints applied to the AR-parameters? It’s vital to use the correct type of parameter vector accordingly.</p>
<div id="unconstrained-gsmar-models" class="section level3">
<h3>Unconstrained GSMAR models</h3>
<p>In the following, the intercept parametrization with intercept parameters <span class="math inline">\(\phi_{m,0}\)</span> is considered. One may alternatively use the mean parametrization; in that case, one simply needs to replace each intercept parameter with the corresponding mean parameter <span class="math inline">\(\mu_m=\phi_{m,0}/(1-\sum_{i=1}^p\phi_{i,m}),\enspace m=1,...,M.\)</span></p>
<div id="the-gmar-model" class="section level4">
<h4>The GMAR model</h4>
<p>The parameter vector for unconstrained GMAR model is a size <em>(M(p+3)-1)x1</em> vector of the form <span class="math display">\[\boldsymbol{\theta}=(\boldsymbol{\upsilon_{1}},...,\boldsymbol{\upsilon_{M}}, \alpha_{1},...,\alpha_{M-1}),\quad where\]</span> <span class="math display">\[\boldsymbol{\upsilon_{m}}=(\phi_{m,0},\boldsymbol{\phi_{m}}, \sigma_{m}^2) \enspace and \enspace \boldsymbol{\phi_{m}}=(\phi_{m,1},...,\phi_{m,p}) ,\quad m=1,...,M.\]</span> Symbol <span class="math inline">\(\phi_{m,i}\)</span> denotes an AR coefficient, <span class="math inline">\(\sigma_m^2\)</span> is a variance parameter and <span class="math inline">\(\alpha_m\)</span> a mixing weight parameter.</p>
</div>
<div id="the-stmar-model" class="section level4">
<h4>The StMAR model</h4>
<p>For the StMAR model, the parameter vector has to be expanded to include the degrees of freedom parameters. The parameter vector for unconstrained StMAR model is thus a size <em>(M(p+4)-1)x1</em> vector of the form <span class="math display">\[(\boldsymbol{\theta}, \boldsymbol{\nu}),\quad where \quad \boldsymbol{\nu}=(\nu_{1},...,\nu_{M})\]</span> contains the degrees of freedom parameters and the parameter <span class="math inline">\(\boldsymbol{\theta}\)</span> is as in the case of the GMAR model. To ensure existence of finite second moments, the degrees of freedom parameters <span class="math inline">\(\nu_{m}\)</span> are assumed to be larger than <span class="math inline">\(2\)</span>.</p>
<div id="the-g-stmar-model-1" class="section level5">
<h5>The G-StMAR model</h5>
<p>In the G-StMAR model the first <code>M1</code> components are GMAR type and the rest <code>M2</code> components are StMAR type. Parameter vector of the G-StMAR model is similar to the one of the StMAR model but with <code>M2</code> degrees of freedom parameters for the StMAR components. That is, a size <code>(M(p+3)+M2-1)x1</code> vector of the form <span class="math display">\[(\boldsymbol{\theta}, \boldsymbol{\nu}),\quad where \quad \boldsymbol{\nu}=(\nu_{M1+1},...,\nu_{M})\]</span> contains the degrees of freedom parameters and the parameter <span class="math inline">\(\boldsymbol{\theta}\)</span> is as in the case of the GMAR model. As in the StMAR case, the degrees of freedom parameters are assumed to be larger than two.</p>
</div>
</div>
</div>
<div id="restricted-gsmar-models" class="section level3">
<h3>Restricted GSMAR models</h3>
<p>In addition to unconstrained GSMAR models, <code>uGMAR</code> gives an option to analyze restricted models whose AR coefficients <span class="math inline">\(\phi_{m,1},...,\phi_{m,p}\)</span> are restricted to be the same for all regimes <span class="math inline">\(m=1,..,M\)</span>. Structure of the parameter vector is different for restricted and non-restricted models.</p>
<div id="the-gmar-model-1" class="section level4">
<h4>The GMAR model</h4>
<p>Parameter vector of the restricted GMAR model is a size <code>(3M-p+1)x1</code> vector of the form <span class="math display">\[\boldsymbol{\theta}=(\phi_{1,0},...,\phi_{M,0},\boldsymbol{\phi},\sigma_{1}^2,...,\sigma_{M}^2,\alpha_{1},...,\alpha_{M-1}),  \quad where \quad \boldsymbol{\phi}=(\phi_{1},...,\phi_{p}).\]</span></p>
</div>
<div id="the-stmar-model-1" class="section level4">
<h4>The StMAR model</h4>
<p>Parameter vector of the restricted StMAR model is then defined by adding the degrees of freedom parameters, yielding a size <code>(4M-p+1)x1</code> vector of the form <span class="math display">\[(\boldsymbol{\theta}, \boldsymbol{\nu}),\quad where \quad \boldsymbol{\nu}=(\nu_{1},...,\nu_{M})\]</span> again contains the degrees of freedom parameters and parameter <span class="math inline">\(\boldsymbol{\theta}\)</span> is as in the case of the GMAR model.</p>
</div>
<div id="g-stmar-model" class="section level4">
<h4>G-StMAR model</h4>
<p>Parameter vector of the restricted G-StMAR model is similar to the StMAR model’s one but with <code>M2</code> degrees of freedom parameters for the StMAR type components.</p>
<p>So one will have to work with different kind of parameter vectors depending on whether you work with restricted or non-restricted model. In order to restrict the AR parameters or to implicate that the parameter vector is restricted, one needs to supply the considered function with the argument <code>restricted=TRUE</code>.</p>
</div>
</div>
<div id="applying-linear-constraints-and-how-it-affects-the-parameter-vector" class="section level3">
<h3>Applying linear constraints and how it affects the parameter vector</h3>
<p><strong>uGMAR</strong> makes it easy to apply linear constraints to the autoregressive parameters of GSMAR models. Considering <em>non-restricted</em> models, each mixture component has its own constraint matrix. <strong>uGMAR</strong> considers constraints of the form <span class="math display">\[\boldsymbol{\phi_{m}}=\boldsymbol{C_{m}\psi_{m}}, \enspace m=1,...,M,\]</span> where <span class="math inline">\(\boldsymbol{C_{m}}\)</span> is a known size <span class="math inline">\((pxq_{m})\)</span> constraint matrix of full column rank and <span class="math inline">\(\boldsymbol{\psi_{m}}\)</span> is a size <span class="math inline">\((q_{m}x1)\)</span> parameter vector. Observe that this particular specification for linear constraints is not the most general one. However, it keeps the constraint matrices small and simple, and it’s convenient for applying the most typical constraints such as constraining some of the AR coefficients to be zero. For instance, in order to constraint the second AR coefficient of the second regime to zero in a model with <code>p=2</code> and <code>M=2</code>, the constraint matrix for the first regime is <code>diag(2)</code> implying no constraints, while the constraint matrix for the second regime is simply <code>matrix(1:0)</code>.</p>
<p>For further illustration, consider the following special case of linear constraints. We obtain a mixture version of the Heterogeneous Autoregressive model (see Corsi 2009 for the original version) by setting <span class="math display">\[\boldsymbol{C_{m}}=\left[{\begin{array}{ccc}
   \boldsymbol{\iota}_{5} &amp; \frac{1}{5}\boldsymbol{1}_{5} &amp; \frac{1}{22}\boldsymbol{1}_{5} \\
   0_{17} &amp; 0_{17} &amp; \frac{1}{22}\boldsymbol{1}_{17} \\
  \end{array}}\right],\]</span> where <span class="math inline">\(\boldsymbol{\iota}_{5}=[1,0,0,0,0]'\)</span> for all regimes <span class="math inline">\(m=1,...,M\)</span> and applying the constraints to the <code>GMAR(22,M)</code> model.</p>
<p>In order to apply the linear constraints in <strong>uGMAR</strong>, one simply needs to parametrize the model with vectors <span class="math inline">\(\boldsymbol{\psi_{m}}\)</span> instead of <span class="math inline">\(\boldsymbol{\phi_{m}}\)</span> and provide the constraint matrices <span class="math inline">\(\boldsymbol{C_{m}}\)</span> in the argument <code>constraints</code> (or if one estimates the parameters, only the constraint matrices need to be provided). Note that despite the lengths of <span class="math inline">\(\boldsymbol{\psi_{m}}\)</span>, the nominal order of AR coefficients is always <span class="math inline">\(p\)</span> for all regimes.</p>
<div id="non-restricted-gsmar-models" class="section level4">
<h4>Non-restricted GSMAR models</h4>
<p>Similarly to the case of unconstrained GMAR model, parameter vector for the constrained GMAR model is of the form <span class="math display">\[\boldsymbol{\theta}=(\boldsymbol{\upsilon_{1}},...,\boldsymbol{\upsilon_{M}}, \alpha_{1},...,\alpha_{M-1}),\]</span> but now the vectors <span class="math inline">\(\boldsymbol{\upsilon_{m}}\)</span> are defined by using the vectors <span class="math inline">\(\boldsymbol{\psi_{m}}\)</span>, that is, <span class="math display">\[\boldsymbol{\upsilon_{m}}=(\phi_{m,0},\boldsymbol{\psi_{m}}, \sigma_{m}^2) \enspace and \enspace \boldsymbol{\psi_{m}}=(\psi_{m,1},...,\psi_{m,q_{m}}), \enspace m=1,...,M.\]</span> The user has to also provide a list of constraint matrices <span class="math inline">\(\boldsymbol{R_{m}}\)</span> that satisfy <span class="math inline">\(\boldsymbol{\phi_{m}}=\boldsymbol{R_{m}\psi_{m}}\)</span> for all <span class="math inline">\(m=1,...,M.\)</span></p>
<p>Parameter vector for the constrained StMAR model is defined by simply adding the degrees of freedom parameters to the GMAR’s parameter vector, that is, <span class="math display">\[(\boldsymbol{\theta}, \boldsymbol{\nu}),\quad where \quad \boldsymbol{\nu}=(\nu_{1},...,\nu_{M}),\]</span> and <span class="math inline">\(\boldsymbol{\theta}\)</span> is as in the case of constrained GMAR model.</p>
<p>Parameter vector for the constrained G-StMAR model is similar to the one of the constrained StMAR model, but with degrees of freedom parameters for the StMAR components only.</p>
</div>
<div id="restricted-gsmar-models-1" class="section level4">
<h4>Restricted GSMAR models</h4>
<p>Analogously non-restricted models, the parameter vectors for constrained versions of restricted GSMAR models are defined by simply replacing vector <span class="math inline">\(\boldsymbol{\phi}\)</span> with vector <span class="math inline">\(\boldsymbol{\psi}\)</span>. Hence the parameter vector for restricted and constrained GMAR model has the form <span class="math display">\[\boldsymbol{\theta}=(\phi_{1,0},...,\phi_{M,0},\boldsymbol{\psi},\sigma_{1}^2,...,\sigma_{M}^2,\alpha_{1},...,\alpha_{M-1}),  \quad where \quad \boldsymbol{\psi}=(\psi_{1},...,\psi_{p}).\]</span> The constraint matrix <span class="math inline">\(\boldsymbol{C}\)</span> needs to be provided and it’s assumed to satisfy <span class="math inline">\(\boldsymbol{\phi}=\boldsymbol{R\psi}.\)</span></p>
<p>Parameter vector for the restricted and constrained StMAR model is then again defined by adding the degrees of freedom parameters, that is <span class="math inline">\((\boldsymbol{\theta}, \boldsymbol{\nu})\)</span> where <span class="math inline">\(\boldsymbol{\nu}=(\nu_{1},...,\nu_{M}).\)</span> For the restricted and constrained G-StMAR model, the parameter vector is similar to the one of restricted and constrained StMAR model but with degrees of freedom parameters for the StMAR components only.</p>
</div>
</div>
</div>
<div id="useful-functions-in-ugmar" class="section level2">
<h2>Useful functions in uGMAR</h2>
<div id="estimating-a-gsmar-model" class="section level3">
<h3>Estimating a GSMAR model</h3>
<p>The function used to estimate models in <code>uGMAR</code> is <code>fitGSMAR</code>. It estimates the model parameters using the method of maximum likelihood and employs a hybrid estimation scheme that is performed in two phases. In the first phase <code>fitGSMAR</code> uses a genetic algorithm to find starting values for the gradient based variable metric algorithm, which it then uses in the second phase for finalize the estimation. It’s important to note that it’s not guaranteed that the numerical estimation algorithms end up in the global maximum point rather than a local one or a saddle point. Because of multimodality and challenging surface of the log-likelihood function, it’s actually expected that many of the estimation rounds won’t find the global maximum point. For this reason one should always perform multiple estimation rounds since more estimation rounds yield more reliable result. The number of estimation rounds can be chosen with the argument <code>ncalls</code> but multiple estimation rounds is also performed default. To shorten the estimation time, <strong>uGMAR</strong> uses parallel computing to run multiple estimation rounds in parallel. The number of cores used can be set with the argument <code>ncores</code>.</p>
<p>There is also an option to perform some quantile residual tests for the estimated model to get a quick sense on how the model fits to the data.</p>
<p>If the model estimates poorly, it’s often because the number of mixture components is chosen too large. One may also adjust settings of the genetic algorithm employed, or set up an initial population with guesses for the estimates. This can by done by passing arguments in <code>fitGSMAR</code> to the (non-exported) function <code>GAfit</code> which implements the genetic algorithm. To check the available settings, read the documentation <code>?GAfit</code>. If the iteration limit is reached when estimating the model, the function <code>iterate_more</code> can be used to finish the estimation.</p>
<p>The parameters of the estimated model are printed in an illustrative and easy to read form. In order to easily compare approximate standard errors to certain estimates, it’s advisable to use the <code>summary</code> method, which prints the errors inside brackets next to the estimates. Numerical approximation of the gradient and Hessian matrix of the log-likelihood function at the estimates can be obtained conveniently with the functions <code>get_gradient</code> and <code>get_hessian</code>. The estimated objects also have their own plot method.</p>
<p>Use the function ‘stmar_to_gstmar’ in order to conveniently switch from a StMAR model with large degrees of freedom estimates to the corresponding G-StMAR model.</p>
</div>
<div id="model-diagnostics" class="section level3">
<h3>Model diagnostics</h3>
<p><strong>uGMAR</strong> considers model diagnostics based on quantile residuals (see Kalliovirta 2012). Quantile residuals are asymptotically standard normal distributed if the model is correctly specified, and they can be hence used for graphical diagnostics and testing.</p>
<p>The function <code>quantileResidualTests</code> performs the quantile residual tests introduced by <em>Kalliovirta (2012)</em>, testing for normality, autocorrelation and conditional heteroscedasticity. For graphical diagnostics, one may use the functions <code>diagnosticPlot</code> and <code>quantileResidualPlot</code>.</p>
<p>Consider installing the suggested package <code>gsl</code> for much faster evaluations of quantile residuals in the cases of StMAR and G-StMAR models. If the model and data are both large, performing quantile residuals tests may take significantly long time for StMAR and G-StMAR models without the package <code>gsl</code> because numerical integration is used. It’s not imported because, in our experience, it might not install to some platforms directly when installing <strong>uGMAR</strong>.</p>
</div>
<div id="constructing-class-gsmar-model-without-estimation" class="section level3">
<h3>Constructing class ‘gsmar’ model without estimation</h3>
<p>One may wish to construct an arbitrary model without estimating the parameters, for example in order to simulate from the particular process of interest. An arbitrary model can be created with the function <code>GSMAR</code>. If one wants to add or update data to the model afterwards, it’s advisable to use the function <code>add_data</code>.</p>
</div>
<div id="simulating-a-gsmar-process" class="section level3">
<h3>Simulating a GSMAR process</h3>
<p>The function <code>simulateGSMAR</code> is the one for the job. As the main argument it uses a <code>gsmar</code> object created with <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</div>
<div id="forecasting-gsmar-process" class="section level3">
<h3>Forecasting GSMAR process</h3>
<p>We advice to directly use the function <code>simulateGSMAR</code> for quantile based forecasting. However, <strong>uGMAR</strong> contains the predict method <code>predict.gsmar</code> for forecasting GSMAR processes. For one step predictions using the exact formula for conditional mean is supported, but the forecasts further than that are based on independent simulations. The predictions are either sample means or medians and the confidence intervals are based on sample quantiles. The objects generated by <code>predict.gsmar</code> have their own plot method.</p>
</div>
<div id="multivariate-versions-of-the-models" class="section level3">
<h3>Multivariate versions of the models</h3>
<p>For analysing multivariate versions of the model, you are welcome to try the package <code>gmvarkit</code>. It currently supports the GMVAR model which is the multivariate extension of the GMAR model.</p>
</div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<ul>
<li>Corsi F. 2009. A Simple Approximate Long-Memory Model of Realized Volatility. <em>Journal of Financial Econometrics</em>, <strong>7</strong>, 174-196.</li>
<li>Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series. <em>Journal of Time Series Analysis</em>, <strong>36</strong>, 247-266.</li>
<li>Kalliovirta L. 2012. Misspecification tests based on quantile residuals. <em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.</li>
<li>Meitz M., Preve D., Saikkonen P. 2018. A mixture autoregressive model based on Student’s t-distribution. arXiv:1805.04010 <strong>[econ.EM]</strong>.</li>
<li>There are currently no published references for the G-StMAR model, but it’s a straightforward generalization with theoretical properties similar to the GMAR and StMAR models.</li>
</ul>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
